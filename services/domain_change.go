package services

import (
	"domain0/bot"
	db "domain0/database"
	"domain0/models"
	mw "domain0/models/web"
	"domain0/modules"
	"encoding/json"
	"github.com/gofiber/fiber/v2"
	"github.com/sirupsen/logrus"
	"net/http"
	"strings"
	"time"
)

// @Summary list all domain change requests generated by the user
// @Tags domain
// @Produce json
// @Success 200 {object} mw.Domain{data=[]models.DomainChange}
// @Failure 500 {object} mw.Domain
// @Router /api/v1/domain/change/myapply [get]
func DomainChangeListMyApply(c *fiber.Ctx) error {
	// extract info
	uid := c.Locals("sub").(uint)

	// get domain change list
	var dcList []models.DomainChange
	err := db.DB.Preload("Domain").Preload("User").Where("user_id = ?", uid).Find(&dcList).Error
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(mw.Domain{
			Status: fiber.StatusInternalServerError,
			Errors: "Database error",
		})
	}

	return c.Status(fiber.StatusOK).JSON(mw.Domain{
		Status: fiber.StatusOK,
		Data:   dcList,
	})
}

// @Summary list all domain change requests that the user can approve
// @Tags domain
// @Produce json
// @Success 200 {object} mw.Domain{data=[]models.DomainChange}
// @Failure 500 {object} mw.Domain
// @Router /api/v1/domain/change/myapprove [get]
func DomainChangeListMyApprove(c *fiber.Ctx) error {
	// extract info
	uid := c.Locals("sub").(uint)

	// get domain change list
	var dcList []models.DomainChange
	err := db.DB.Preload("Domain").Preload("User").Where(
		"domain_id IN (SELECT domain_id FROM user_domains WHERE user_id = ? AND role >= ?)",
		uid, models.Owner,
	).Find(&dcList).Error
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(mw.Domain{
			Status: fiber.StatusInternalServerError,
			Errors: "Database error",
		})
	}

	return c.Status(fiber.StatusOK).JSON(mw.Domain{
		Status: fiber.StatusOK,
		Data:   dcList,
	})
}

// @Summary modify domain change request
// @Tags domain
// @Produce json
// @Param id path string true "domain change id"
// @Param opt query string true "operation: accept or reject"
// @Success 200 {object} mw.Domain{data=models.DomainChange}
// @Failure 500 {object} mw.Domain
// @Router /api/v1/domain/change/{id} [put]
func DomainChangeCheck(c *fiber.Ctx) error {
	// extract info
	uid := c.Locals("sub").(uint)

	// get domain change id
	dcId := c.Params("id")
	opt := c.Query("opt")

	// get domain change
	var dc models.DomainChange
	err := db.DB.Where("id = ?", dcId).First(&dc).Error
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(mw.Domain{
			Status: fiber.StatusNotFound,
			Errors: "Domain change not found",
		})
	}

	// check permission
	var ud models.UserDomain
	err = db.DB.Where("domain_id = ? AND user_id = ? AND role >= ?", dc.DomainId, uid, models.Owner).First(&ud).Error
	if err != nil {
		return c.Status(fiber.StatusForbidden).JSON(mw.Domain{
			Status: fiber.StatusForbidden,
			Errors: "Permission denied",
		})
	}

	// oprate
	if opt == "accept" {
		dc.ActionStatus = models.Approved
		var d models.Domain
		if err := db.DB.Where("id = ?", dc.DomainId).First(&d).Error; err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(mw.Domain{
				Status: fiber.StatusInternalServerError,
				Errors: "Database error",
			})
		}
		dcs := modules.DnsChangeStruct{
			Dns:    modules.DnsObjGen(&d),
			Domain: d,
		}
		if err := json.Unmarshal([]byte(dc.Operation), &dcs); err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(mw.Domain{
				Status: fiber.StatusInternalServerError,
				Errors: "Database error",
			})
		}
		if err := dcs.DnsChangeRestore(); err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(mw.Domain{
				Status: fiber.StatusInternalServerError,
				Errors: "Database error",
			})
		}
		var err error
		if dc.ActionType == models.Submit {
			err = dcs.Dns.Create()
		} else if dc.ActionType == models.EditDNS {
			err = dcs.Dns.Update()
		}
		if err != nil {
			return c.Status(fiber.StatusInternalServerError).JSON(mw.Domain{
				Status: fiber.StatusInternalServerError,
				Errors: "Database error",
			})
		}
	} else if opt == "reject" {
		dc.ActionStatus = models.Rejected
	} else {
		return c.Status(fiber.StatusBadRequest).JSON(mw.Domain{
			Status: fiber.StatusBadRequest,
			Errors: "Invalid opt",
		})
	}

	// update domain change
	err = db.DB.Save(&dc).Error
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(mw.Domain{
			Status: fiber.StatusInternalServerError,
			Errors: "Database error",
		})
	}

	return c.Status(fiber.StatusOK).JSON(mw.Domain{
		Status: fiber.StatusOK,
		Data:   dc,
	})
}

func DomainChangeNotify(c *fiber.Ctx) error {
	if method := c.Method(); method == http.MethodGet {
		return c.Next()
	}
	if path := c.Path(); strings.HasPrefix(path, "/api/v1/domain/change") {
		return c.Next()
	}

	err := c.Next()

	go func() {
		notifyFeishu(c)
	}()

	return err
}

func notifyFeishu(c *fiber.Ctx) {
	url := c.BaseURL() + c.Path()
	userName := c.Locals(localsUserName).(string)
	isSuccess := c.Response().StatusCode()/100 == 2
	domainName := getDomainNameIfPossible(c)
	record := bot.DomainModifyRecord{
		UserName:      userName,
		Domain:        domainName,
		OperationUrl:  url,
		OperationTime: time.Now(),
		Result:        isSuccess,
	}
	bot.NotifyDomainChange([]bot.DomainModifyRecord{record})
}

func getDomainNameIfPossible(c *fiber.Ctx) string {
	if c.Path() == "/api/v1/domain" && c.Method() == http.MethodPost {
		return getDomainNameThroughResp(c)
	} else {
		return getDomainNameByDomainId(c)
	}
}

func getDomainNameThroughResp(c *fiber.Ctx) string {
	response := c.Response()
	var domainResp mw.Domain
	originBody := response.Body()
	copyBody := make([]byte, len(originBody))
	copy(copyBody, originBody)
	if err := json.Unmarshal(copyBody, &domainResp); err != nil {
		logrus.Errorf("parse response body err: %v", err)
		return ""
	}
	domainInfoUpdate := domainResp.Data.(mw.DomainInfoUpdate)
	return *domainInfoUpdate.Name
}

func getDomainNameByDomainId(c *fiber.Ctx) string {
	domainName := ""
	domainId := c.Params("id", "-1")
	if domainId != "-1" {
		var domain models.Domain
		if queryDbErr := db.DB.Where("id = ?", domainId).First(&domain).Error; queryDbErr != nil {
			// just log the db err, don't block
			logrus.Errorf("query db error:%v", queryDbErr)
		}
		domainName = domain.Name
	}
	return domainName
}
